{
  "texts": {
    "GeeksforGeeks": "Amazon SDE Sheet: Interview Questions and Answers 2024\nLast Updated :\n01 Oct, 2025\nComments\nImprove\nSuggest changes\n96 Likes\nLike\nReport\nAmazon SDE sheet is the collection of the most important topics or the most frequently asked question in Amazon Software Development Engineer Interviews. Here we have collected all the interview questions and answers to land a job on Amazon\nTo get employed by Amazon is a dream for many. One must have clear\nData Structure\nconcepts\ngood communication skills\n, and\nanalytical thinking\nand should be able to solve real-world problems to crack top companies like Amazon. Steps to follow to get a chance at Amazon are:\nOnline Application\nOnline test:\n(60 mins) 2 coding questions of medium difficulty level. The Amazon online test (20 questions) is based on OOPs, DBMS, operating systems, data structures, and algorithms.\nTechnical Interview 1:\nProject discussions, coding questions based on DS algorithms, and quizzes. It basically tests real-world problem-solving skills.\nTechnical Interview 2:\nQuestions of relatively higher difficulty level (mostly DS and algorithms-based)\nBar raiser round:\nBehavioral questions and project discussions. Some technical questions are followed by an assessment of leadership quality and cultural fit.\nFor one to land a job at Amazon, he/she must have clear concepts of DSA and good practice of questions on sorting, array, string, Linked List, searching, sorting, stack, queue, tree, graph recursion backtracking dynamic programming, etc. Here through this Amazon SDE sheet, we are providing most of the coding questions which frequently pop up in amazon interviews topic-wise. This collection of interview questions will help you prepare better for your interview.\nComputer Fundamentals\nThere are three focused computer subjects, on the basis of those subjects MCQs will be there, we have designed top MCQs for that, so you can easily test your knowledge on those subjects.\nOOP MCQs with Answers\nDBMS MCQs with Answers\nOperating System MCQs with Answers\nData Structures MCQs with Answers\nAlgorithms MCQs with Answers\nLanguage Based Questions\nThey can be asked language-based questions, to check your grasp of the language you used for the coding round.\nC Multiple Choice Questions\nC++ Multiple Choice Questions\nJava Multiple Choice Questions\nData Structure & Algorithms\nArray\narray\nis a collection of items stored at contiguous memory locations. The idea is to store multiple items of the same type together.\nArticles\nPractice\nLargest Sum Contiguous Subarray\nSolve\nSearch in a row-wise and column-wise sorted matrix\nSolve\nPrint a given matrix in spiral form\nSolve\nProgram for array rotation\nSolve\nTrapping Rain Water\nSolve\nCount pairs with given sum\nSolve\nFind the subarray with least average\nSolve\nConvert array into Zig-Zag fashion\nSolve\nFind duplicates in an array\nSolve\nFind a triplet that sum to a given value\nSolve\nString\nString\nare defined as an array of characters. The difference between a character array and a string is the string is terminated with a special character ‘\\0’.\nArticles\nPractice\nValidate an IP Address\nSolve\nMultiply Strings\nSolve\nImplement Atoi\nSolve\nCheck if the string is rotated by two places\nSolve\nPermutations of a given string\nSolve\nLongest Repeating Subsequence\nSolve\nRoman Number to Integer\nSolve\nLength of the longest substring\nSolve\nString formation from substring\nSolve\nCheck whether two strings are an anagram of each other\nSolve\nLook-and-Say Sequence\nSolve\nRemove minimum number of characters so that two strings become anagram\nSolve\nFind the smallest window in a string containing all characters of another string\nSolve\nLength of the longest substring without repeating characters\nSolve\nLinked List\nLinked List\nis the data structure that can overcome all the limitations of an array.\nA Linked list is a linear data structure, in which the elements are not stored at contiguous memory locations, it allocates memory dynamically.\nArticles\nPractice\nReverse a linked list\nSolve\nSegregate even and odd nodes in a Linked List\nSolve\nDetect loop in a linked list\nSolve\nDelete all occurrences of a given key in a linked list\nSolve\nRemove loop in Linked List\nSolve\nNth node from the end of linked list\nSolve\nMerge K sorted linked lists\nSolve\nFlatten a binary tree into linked list\nSolve\nAdd two numbers represented by linked lists\nSolve\nFunction to check if a singly linked list is palindrome\nSolve\nClone a linked list with next and random pointer\nSolve\nDelete without head pointer\nSolve\nGiven a linked list of 0s, 1s and 2s, sort it\nSolve\nIntersection of Two Linked Lists\nSolve\nSearching\nSearching\nAlgorithms are designed to check for an element or retrieve an element from any data structure where it is stored.\nArticles\nPractice\nSearch an element in a sorted and rotated array\nSolve\nSquare root of an integer\nSolve\nFirst and last occurrences of x\nSolve\nFind a peak element\nSolve\nFind the smallest positive number missing from an unsorted array\nSolve\nAllocate minimum number of pages\nSolve\nCounting elements in two arrays\nSolve\nMedian of two sorted arrays of different sizes\nSolve\nSorting\nSorting\nAlgorithm is used to rearrange a given array or list of elements according to a comparison operator on the elements. The comparison operator is used to decide the new order of elements in the respective data structure.\nArticles\nPractice\nk largest(or smallest) elements in an array\nSolve\nSort an array of 0s, 1s, and 2s\nSolve\nCount Inversions in an array\nSolve\nMerge Without Extra Space\nSolve\nMinimum Platforms\nSolve\nQuick Sort\nSolve\nHeap Sort\nSolve\nMerge k Sorted Arrays\nSolve\nOverlapping Intervals\nSolve\nStack\nstack\nis a linear data structure in which elements can be inserted and deleted only from one side of the list, called the top. A stack follows the LIFO (Last In First Out) principle.\nArticles\nPractice\nCheck for Balanced Brackets in an expression (well-formedness) using Stack\nSolve\nSort a stack using recursion\nSolve\nThe Celebrity Problem\nSolve\nNext Greater Element\nSolve\nQueue using two Stacks\nSolve\nQueue\nQueue\nis a linear data structure in which elements can be inserted only from one side of the list called rear, and the elements can be deleted only from the other side called the front. The queue data structure follows the FIFO (First In First Out) principle.\nArticles\nPractice\nStack using two queues\nSolve\nConnect n ropes with minimum cost\nSolve\nMinimum time required to rot all oranges\nSolve\nFirst negative integer in every window of size k\nSolve\nReversing a Queue\nSolve\nTree\ntree\nis non-linear and a hierarchical data structure consisting of a collection of nodes such that each node of the tree stores a value, a list of references to nodes (the “children”).\nArticles\nPractice\nInorder Traversal\nSolve\nPreorder Traversal\nSolve\nKth largest element in BST\nSolve\nLeft View of Binary Tree\nSolve\nRight View of Binary Tree\nSolve\nCheck for BST\nSolve\nDiameter of a Binary Tree\nSolve\nBoundary Traversal of binary tree\nSolve\nHeight of Binary Tree\nSolve\nLowest Common Ancestor in a Binary Tree\nSolve\nBinary Tree to DLL\nSolve\nRoot to leaf path sum\nSolve\nReverse Level Order Traversal\nSolve\nConstruct Tree from Inorder & Preorder\nSolve\nZigZag Tree Traversal\nSolve\nKth largest element in BST\nSolve\nSerialize and Deserialize a Binary Tree\nSolve\nGraph\nGraph\nis a non-linear data structure consisting of nodes and edges. The nodes are sometimes also referred to as vertices and the edges are lines or arcs that connect any two nodes in the graph.\nArticles\nPractice\nBFS of Graph\nSolve\nDFS of Graph\nSolve\nFind the number of islands\nSolve\nTopological sort\nSolve\nSteps by Knight\nSolve\nStrongly Connected Components (Kosaraju's Algo)\nSolve\nAlien Dictionary\nSolve\nDijkstra Algorithm\nSolve\nDetect Cycle in a Directed Graph\nSolve\nDetect cycle in an undirected graph\nSolve\nTrie\nTrie is an efficient information retrieval data structure. Using Trie, search complexities can be brought to optimal limit (key length).\nArticles\nPractice\nTrie Insert and Search\nSolve\nTrie Delete\nSolve\nPrint unique rows in a given Binary matrix\nSolve\nCounting the number of words in a Trie\nSolve\nLongest Common Prefix using Trie\nSolve\nMinimum XOR Value Pair\nSolve\nPalindrome pair in an array of words (or strings)\nSolve\nHeap\nand\nHash\nA Heap is a special Tree-based data structure in which the tree is a complete binary tree. Heap and hash is an efficient implementation of a priority queue. The linear hash function monotonically maps keys to buckets, and each bucket is a heap.\nArticles\nPractice\nMinimum Cost of ropes\nSolve\nk largest elements\nSolve\nKth element in Matrix\nSolve\nFind median in a stream\nSolve\nKth largest element in a stream\nSolve\nRearrange characters\nSolve\nNearly sorted\nSolve\nNuts and Bolts Problem\nSolve\nCheck if two strings are k-anagrams or not.\nSolve\nSort an array according to the other\nSolve\nSwapping pairs make sum equal\nSolve\nSmallest distinct window\nSolve\nFind first repeated character\nSolve\nBitMagic\nBit stands for binary digit. A bit is the basic unit of information and can only have one of two possible values that is 0 or 1.\nArticles\nPractice\nFind the Missing Number\nSolve\nPower of 2\nSolve\nReverse Bits\nSolve\nMaximum subset XOR\nSolve\nCheck set bits\nSolve\nMinimum X (xor) A\nSolve\nLongest Consecutive 1's\nSolve\nNumber of 1 Bits\nSolve\nRecursion and Backtracking\nRecursion\nThe process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function.\nBacktracking\nBacktracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point in time (by time, here, is referred to the time elapsed till reaching any level of the search tree).\nArticles\nPractice\nWrite a program to print all permutations of a given string\nSolve\nRat in a Maze Problem - I\nSolve\nJosephus problem\nSolve\nCombination Sum\nSolve\nPartition Equal Subset Sum\nSolve\nN-Queen Problem\nSolve\nShuffle integers\nSolve\nHamiltonian Path\nSolve\nFind the string in grid\nSolve\nPascal Triangle\nSolve\nSolve the Sudoku\nSolve\nLargest number in K swaps\nSolve\nDynamic Programming\nDynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for same inputs, we can optimize it using Dynamic Programming.\nArticles\nPractice\n0 - 1 Knapsack Problem\nSolve\nPartition Equal Subset Sum\nSolve\nCoin Change\nSolve\nLongest Common Subsequence\nSolve\nStock buy and sell\nSolve\nInterleaved Strings\nSolve\nEdit Distance\nSolve\nStickler Thief\nSolve\nLongest Common Substring\nSolve\nNumber of Coins\nSolve\nEgg Dropping Puzzle\nSolve\nWord Break\nSolve\nWildcard Pattern Matching\nSolve\nTotal Decoding Messages\nSolve\nJump Game\nSolve\nSpecial Keyboard\nSolve\nLongest Palindromic Subsequence\nSolve\nAfter qualifying the Online test you have to face 2 technical interviews, where they asked about Data Structure, algorithms, and different kinds of puzzles. Technical rounds are face-to-face algorithmic rounds in which candidates are presented with 2-4 questions, all from data structures. The most commonly asked DSs are the matrix, binary tree, BST, and Linked list. The second technical round is more difficult and more questions from Trees, BST, and Graph are asked. One should have a clear knowledge of tree-based recursion, and the standard questions based on it are a must.\nP.S:\nAfter solving all the problems mentioned above you can answer the questions which will be asked in these rounds.\nPuzzles\nPuzzles are one of the ways to check your problem-solving skills. These are tricky questions that let you think logically. Amazon will test your problem-solving skills through the puzzles as well. Try to solve these\n20 Puzzles Commonly Asked During SDE Interviews\nProject Discussion\nThoroughly revise all the work you have done till now in your projects. The grilling about projects can sometimes be very deep. Mention only those topics where you think you are fine to be grilled upon. If you don't have any project they will not ask about it, but better to have some projects, it involves questions like what's new in your project if you have created a basic clone, or what's your input followed by questions based on your technology stack.\nNote:\nIf you have a project on AWS then you have to be confident enough to provide sufficient answers of each question,\nTo let you know in details about Amazon Recruitment Process, we have a article on that too so you can go through this post:\nhttps://www.geeksforgeeks.org/interview-experiences/amazon-recruitment-process/\nComment\nkartik\nFollow\nImprove\nkartik\nFollow\nImprove\nArticle Tags :\nDSA\nSoftware Development\nInterview Questions\nAmazon\nInterview-Questions\nGFG Sheets\nSDE Sheet\nCompany SDE Sheet\n+4 More",
    "InterviewBit": "Interview Guides\nAmazon Interview Questions\nAmazon Interview Questions\nLast Updated: Nov 10, 2023\nJump to Problems\n✨ 200 Amazon Interview Questions Found\nCopied\nPowered by\nCertificate included\nAbout the Speaker\nWhat will you Learn?\nI wish to receive further updates and confirmation via whatsapp\nRegister Now\nAbout Amazon\nEarth's most 'Customer Centric' company, Amazon was founded by Jeff Bezos from his garage in Bellevue, Washington on July 5, 1994. Amazon is an American multinational technology company whose focus is on a large number of fields, for instance, E-Commerce, Cloud Computing, Artificial Intelligence, Digital Streaming, etcetera. It is considered to be one of the Big Five companies in the United States Information Technology industry, along with Google, Apple, Microsoft, and Facebook.\nAmazon is renowned for its huge disruption of industries through technological innovation and mass scale. Being the world's largest online marketplace, AI assistant provider, and cloud computing platform, Amazon has a workforce of over six lakh employees, out of which over fifty thousand are Indians. It is the largest Internet company by revenue in the world right now and the second-largest private employer in the United States. Because of this, Amazon has the highest global brand valuation.\nGiven the plethora of services that Amazon offers, it is pretty obvious that a lot of people want to join Amazon and be part of its evergreen culture. But what really is the secret sauce to Amazon’s humongous success? Well, if you ask this question to any of the employees at Amazon, we are pretty sure that everyone would unanimously say: 'The Leadership Principles of Amazon'\nPlay\nAmazon Interview Preparation\n1. Interview Preparation Tips\nNow that we know about the rich heritage of Amazon, its work culture, and its Leadership Principles, I am sure that you will be tempted to interview at Amazon and take a job! Here are a few tips which you can use to crack Amazon's interview and get a job\nUnderstand the Leadership Principles Well\n- As mentioned before, Amazonians take great pride as far as their Leadership Principles are concerned. Therefore, knowing about these principles and citing an instance or two where the candidate has applied them in real life will have a positive impact on the interviewers. This leaves an impression that the candidate is genuinely interested in working with the company.\nBe Thorough with Data Structures and Algorithms\n- At Amazon, there is always an appreciation for great problem solvers. If you want to have a good impression of the interviewers, the best way is to prove that you have worked a lot on developing your logic structures and solving algorithmic problems. A good understanding of Data Structures and Algorithms and having one or two good projects always earn you brownie points with Amazon.\nUse the STAR method to format your Response\n- STAR is an acronym for Situation, Task, Action, and Result. The STAR method is a structured way to respond to behavioral-based interview questions. To answer a provided question using the STAR method, you start by describing the situation that was at hand, the Task which needed to be done, the action taken by you as a response to the Task, and finally the Result of the experience. It is important to think about all the details and recall everyone and everything that was involved in the situation. Let the interviewer know how much of an impact that experience had on your life and in the lives of all others who were involved. It is always good practice to be prepared with a real-life story that you can describe using the STAR method.\nKnow and Describe your Strengths\n- Many people who interview at various companies, stay shy during the interviews and feel uncomfortable when they are asked to describe their strengths. Remember that if you do not show how good you are at the skills you know, no one will ever be able to know about the same and this might just cost you a lot. So it is okay to think about yourself and highlight your strengths properly and honestly as and when required.\nDiscuss with your interviewer and keep the conversation going\n- Remember that an interview is not a written exam and therefore even if you come up with the best of solutions for the given problems, it is not worth anything until and unless the interviewer understands what you are trying to say. Therefore, it is important to make the interviewer that he or she is also a part of the interview. Also, asking questions might always prove to be helpful during the interview.\nCreate a free personalised study plan\nCreate a FREE custom study plan\nGet into your dream companies with expert guidance\nGet into your dream companies with expert..\nReal-Life Problems\nPrep for Target Roles\nCustom Plan Duration\nFlexible Plans\nCreate My Plan\nAmazon Recruitment Process\n1. Interview Process\nRecruiter Connect:\nBest way to get noticed by Amazon recruiters is to maintain a good Linkedin profile and message recruiters. The candidate can also apply on the Amazon job portal but it is suggested that they also get a referral from an Amazon employee.\nInterview Rounds\n: Amazon conducts four interview rounds alongside an initial coding test. The coding test consists of DS/Algo problems. The first round is an HR round where they ask behavioral questions along with Computer Science theory questions to the candidate. The next three rounds focus solely on DS/Algo.\nAfter Interviews:\nThe recruiter contacts the candidate after these rounds and tells the verdict. They also look at the candidate’s leadership principles along with technical skills.\nHired:\nOnce the team and you both are comfortable and ready to start, the offer letter is prepared and shared with you by the recruiters and you are HIRED!\n2. Interview Rounds\nHR Round(1 Round):\nThis is when they ask computer science theory and behavioural questions to the candidate. The questions may enquire about the candidate’s experience at previous companies and conflicts the candidate might have faced with colleagues/managers.\nData Structures and Algorithms Rounds(3 Rounds):\nThe candidate is asked DS/Algo problems where production ready code might be expected from the candidate. It is not out of the realm of possibility to face minor behavioural questions here as well. The problems range from easy to hard but they are not the sole deciding factor for the final offer. Leadership principles also come into play here. The interviews are conducted on Amazon Chime.\nYou can download a PDF version of Amazon Interview Questions.\nDownload PDF\nDownload PDF\nDownload PDF\nYour requested download is ready!\nClick\nhere\nto download.\nFrequently Asked Questions\n1. What are the Amazon interview rounds?\nThere are 5 rounds (4- Data Structures and Algorithms, 1- System Design, and 1- HR) at Amazon.\n2. Are Amazon interviews hard?\nThe toughness of an interview depends upon the amount of hard work you have put in to prepare for them. Usually, the questions asked in a standard Amazon interview are of Easy to Medium Level but it varies from person to person.\nLearn via our Video Courses\n3. How do I apply for a job at Amazon?\nYou can go to the Amazon Jobs portal and apply for any open role matching your skill set over there.\n4. Can I apply for multiple roles at Amazon?\nYes, we can apply to any role that aligns with both our interests and skills. We are evaluated against the requirements for each role and we can give interviews for different roles at the same time.\nAdvance your career with\nMock Assessments\nRefine your coding skills with Mock Assessments\nReal-world coding challenges for top company interviews\nReal-world coding challenges for top companies\nReal-Life Problems\nDetailed reports\nAttempt Now\n5. What are some of the questions which one should ask the interviewer at Amazon?\nIt is always nice to ask questions about the company's culture and what is the current technology using which the company makes its products. Asking about the future innovations at Amazon also might be a good idea as it might make the interviewer believe that you are looking forward to joining Amazon for a long time. You can also ask about the interviewer's personal experience at Amazon and what skills you must develop before you join the job.\n6. How to prepare for the coding interviews at Amazon?\nThe secret lies in the amount of practice you do. Put in a lot of effort in solving challenging problems on Data Structures and Algorithms. Having a good knowledge of fundamental Computer Science Concepts like Object-Oriented Programming, Computer Networks, Operating Systems, etc. might also be helpful.\n7. Does Amazon have a dress code?\nNo, Amazon does not have a dress code. However, all employees are supposed to wear decent clothes at their respective places of work.\n8. Is having a project on Web or Android Development or Machine Learning a must for being hired at Amazon?\nNo, only good problem-solving skills are required to get hired at Amazon for an SDE position. Having said that, you will always get brownie points if you have a good project or two in your Resume as it shows that you are referenced and interested in the domain on which you have made your project.\nCoding Problems\n0/4\nEasy Problems\nGreedy Algorithm\nDynamic Programming\nMajority Element\nEasy\n19.7 Mins\nSolve\nUnique Binary Search Trees\nEasy\n62.0 Mins\nSolve\nBest Time to Buy and Sell Stocks II\nEasy\n40.18 Mins\nSolve\nBest Time to Buy and Sell Stocks I\nEasy\n28.13 Mins\nSolve\n0/5\nIntermediate Problems\nGreedy Algorithm\nDynamic Programming\nGas Station\nMedium\n56.42 Mins\nSolve\nDistribute Candy\nMedium\n65.48 Mins\nSolve\nLongest Increasing Subsequence\nMedium\n30.39 Mins\nSolve\nMax Product Subarray\nMedium\n65.25 Mins\nSolve\nWays to Decode\nMedium\n70.8 Mins\nSolve\n0/1\nAdvanced Problems\nDynamic Programming\nBest Time to Buy and Sell Stocks III\nHard\n64.56 Mins\nSolve\nView All Problems\nExcel at your interview with Masterclasses\nKnow More\nCertificate included\nWhat will you Learn?\nI wish to receive further updates and confirmation via whatsapp\nRegister Now For FREE!\nPowered By\nYou Have Successfully registered!\nJoin our WhatsApp group for free learning material and session link.",
    "PrepInsta": "PrepInsta would like to send you awesome updates and offers!\nNotifications can be turned off anytime from browser settings\nDon't Allow\nAllow\nUnlock this article for Free,\nby logging in\nDon’t worry, unlock all articles / blogs on PrepInsta by just simply logging in on our website\nSign in with Google\nSign in with Google. Opens in new tab\nAmazon Coding Questions\nJuly 5, 2023\nAmazon Coding Questions and Answers\nOn this page, the 2024 Amazon Coding Questions and Answers are discussed. One of the most crucial rounds for landing a job at Amazon is the coding round.\nYou can use this section to analyse the level of complexity of the Amazon problem. Understanding the level of complexity and question format for the coding phase is made easier by practising Amazon code questions and answers.\nThe Amazon Coding Round questions and their solutions in different languages can be found below. For a good grade, you must be prepared for the Amazon code problems.\nCoding Test Format\nThe Amazon coding round is an important step in the interview process.\nIt assesses a candidate’s problem-solving skills and ability to apply algorithms and data structures to solve coding problems.\nCoding round contains 3 questions that will have to be attended in 3 hours.\nEach questions have different difficulty level.\nThere is one\nEasy\nproblem based on\nAlgorithm\nAptitude\nand\nData structures\nOne of the problem is of\nMedium\nlevel and that problem is based on\nGreedy Algorithm\nOne is of\nHard\ndifficulty level, and usually based on\nDynamic Programming\nNo Of Questions\nMarks per question\nQuestion 1\nQuestion 2\nQuestion 3\nPrime Course Trailer\nRelated Banners\nGet PrepInsta Prime & get Access to all 200+ courses offered by PrepInsta in One Subscription\nGet Prime\nQuestion 1\nProblem Statement:\nCheck if strings are rotations of each other or not\nGiven two strings s1 and s2. The task is to check if s2 is a rotated version of the string s1. The characters in the strings are in lowercase.\nTest Case 1:\nInput:\nmightandmagic\nandmagicmigth\nOutput:\nExplanation:\nHere with any amount of rotation s2 can’t be obtained by s1.\nYour Task:\nThe task is to complete the function\nareRotations()\nwhich checks if the two strings are rotations of each other. The function returns true if string 1 can be obtained by rotating string 2, else it returns false.\nExpected Time Complexity:\nO(N).\nExpected Space Complexity:\nO(N).\nNote:\nN = |s1|.\nConstraints:\n1 <= |s1|, |s2| <= 107\nJava\nC++\nJava\nRun\nimport\njava\nutil\n.*;\npublic\nclass\nMain\npublic\nstatic\nvoid\nmain\nString\nargs\nScanner\nnew\nScanner\nSystem\nint\nnextInt\n();\nint\nprice\nnew\nint\nfor\nint\ni diff\nnew\nVector\n();\nfor\nint\n--)\ndiff\nadd\nprice\nprice\n]);}\nint\nans\nsolve\ndiff\nans\nSystem\nout\nprintln\n);}\nelse\nSystem\nout\nprintln\nans\n);}\nprivate\nstatic\nint\nsolve\nVector\nint\nsize\n();\nreturn\nint\nget\nfor\nint\n++)\nMath\nmax\nget\n));}\nreturn\nint\nmxSum\ncsum\nfor\nint\n++)\ncsum\nget\ncsum\ncsum\nmxSum\nMath\nmax\ncsum\nmxSum\n);}\nreturn\nmxSum\nC++\nRun\n#include\nbits\nstdc\n++.\nusing\nnamespace\nstd\nclass\nMain\npublic\nbool\nRotation\nstring\nstring\nint\nsize\nint\nsize\nreturn\nfalse\nstring\ntemp\ntemp\nfind\nreturn\nfalse\nint\nmain\nint\ncin\nwhile\n--)\nstring\nstring\ncin\nSolution\nobj\ncout\nobj\nRotation\n)<<\nendl\nreturn\nRun\n#include\n<stdio.h>\n#include\n<string.h>\nint\nareRotations\nchar\nchar\nint\nlen1\nstrlen\nint\nlen2\nstrlen\nlen1\nlen2\nreturn\nchar\ntemp\n200\nstrcpy\ntemp\nstrcat\ntemp\nstrstr\ntemp\nreturn\nreturn\nint\nmain\nchar\n100\n100\nprintf\n\"Enter string 1: \"\nscanf\n\"%s\"\nprintf\n\"Enter string 2: \"\nscanf\n\"%s\"\nint\nresult\nareRotations\nresult\nprintf\n\"1\\n\"\nelse\nprintf\n\"0\\n\"\nreturn\nQuestion 2\nProblem Statement:\nJarvis is weak in computing palindromes for Alphanumeric characters.\nWhile Ironman is busy fighting Thanos, he needs to activate sonic punch but Jarvis is stuck in computing palindromes.\nYou are given a string\ncontaining alphanumeric characters. Find out whether the string is a palindrome or not.\nIf you are unable to solve it then it may result in the death of Iron Man.\nTest Case 1:-\nInput:\nS = “I am :IronnorI Ma, i”\nOutput:\nYES\nExplanation:\nIgnore all the symbols and whitespaces S = “IamIronnorIMai”. Now, Check for palindrome ignoring uppercase and lowercase English letter.\nTest Case 2:-\nInput:\nS = Ab?/Ba\nOutput:\nYES\nExplanation:\nHere with any amount of rotation s2 can’t be obtained by s1.\nYour Task:\nThis is a function problem. The input is already taken care of by the driver code. You only need to complete the function\nsaveIronman()\nthat takes an string\n(ch)\n, and return the\ntrue\nif the string is a palindrome and\nfalse\nif the string is not a palindrome. The driver code takes care of the printing.\nExpected Time Complexity:\nO(N).\nExpected Space Complexity:\nO(1).\nNote:\nN = |s1|.\nConstraints:\n1 ≤ |S| ≤ 100000\nNote:\nConsider\nalphabets and numbers only\nfor palindrome check. Ignore symbols and whitespaces.\nJava\nC++\nJava\nRun\nimport\njava\nutil\n.*;\nimport\njava\nlang\n.*;\nimport\njava\n.*;\nclass\nMain\npublic\nstatic\nvoid\nmain\nString\nargs\nthrows\nException\nBufferedReader\nnew\nBufferedReader\nnew\nInputStreamReader\nSystem\n));\nString\nreadLine\n();\ntoLowerCase\n();\nreplaceAll\n\" [,?/:;!]\"\nchar\ntoCharArray\n();\nint\nint\nlength\nboolean\ncheck\ntrue\nwhile\ncheck\nfalse\n++;\ncontinue\ncheck\nfalse\n--;\ncontinue\n]))\ncheck\nfalse\nbreak\n++;\n--;\ncheck\nSystem\nout\nprintln\n\"YES\"\nelse\nSystem\nout\nprintln\n\"NO\"\npublic\nstatic\nboolean\ncheck\nchar\nboolean\nfalse\nbyte\nbyte\n122\nreturn\ntrue\nelse\n'1'\n'2'\n'3'\n'4'\n'5'\n'6'\n'7'\n'8'\n'9'\n'0'\nreturn\ntrue\nreturn\nC++\nRun\n#include\n<iostream>\n#include\n<cctype>\n#include\n<string>\nusing\nnamespace\nstd\nbool\nisPalindrome\nconst\nstring\nstr\nint\nstr\nlength\nwhile\n// Skip symbols and whitespaces\nwhile\nisalnum\nstr\n++;\nwhile\nisalnum\nstr\n--;\n// Convert characters to lowercase for comparison\nchar\nleft\ntolower\nstr\n]);\nchar\nright\ntolower\nstr\n]);\nleft\nright\nreturn\nfalse\n++;\n--;\nreturn\ntrue\nint\nmain\nstring\nstr\ngetline\ncin\nstr\n// Read input string with spaces\nisPalindrome\nstr\ncout\n\"YES\\n\"\nelse\ncout\n\"NO\\n\"\nreturn\nRun\n#include\n<stdio.h>\n#include\n<ctype.h>\n#include\n<stdbool.h>\nbool\nisPalindrome\nchar\n[],\nint\nlen\nint\nlen\nwhile\n// Skip symbols and whitespaces\nwhile\nisalnum\n++;\nwhile\nisalnum\n--;\n// Convert characters to lowercase for comparison\nchar\nleft\ntolower\n]);\nchar\nright\ntolower\n]);\nleft\nright\nreturn\nfalse\n++;\n--;\nreturn\ntrue\nint\nmain\nchar\n100001\nscanf\n\" %[^\\n]s\"\n// Read input string with spaces\nint\nlen\nfor\nint\n'\\0'\n++)\nlen\n++;\nisPalindrome\nlen\nprintf\n\"YES\\n\"\nelse\nprintf\n\"NO\\n\"\nreturn\nQuestion 3\nProblem Statement:\nGiven a binary tree, print the bottom view from left to right.\nA node is included in bottom view if it can be seen when we look at the tree from bottom.\n/ \\\n5 3\n/ \\\nFor the above tree, the bottom view is 5 10 3 14 25.\nIf there are\nmultiple\nbottom-most nodes for a horizontal distance from root, then print the later one in level traversal. For example, in the below diagram, 3 and 4 are both the bottommost nodes at horizontal distance 0, we need to print 4.\n/ \\ / \\\n5 3 4 25\n/ \\\n10 14\nFor the above tree the output should be 5 10 4 14 25.\nExample 1:\nInput:\n/ \\\n3 2\nOutput:\n3 1 2\nExplanation:\nFirst case represents a tree with 3 nodes and 2 edges where root is 1, left child of 1 is 3 and right child of 1 is 2.\nExample 2:\nInput:\n/ \\\n20 30\n/ \\\n40 60\nOutput:\n40 20 60 30\nYour Task:\nThis is a functional problem, you\ndon’t\nneed to care about input, just complete the function\nbottomView\n() which takes the root node of the tree as input and returns an array containing the bottom view of the given tree.\nExpected Time Complexity:\nO(N).\nExpected Auxiliary Space:\nO(N).\nConstraints:\n1 <= Number of nodes <= 105\n1 <= Data of a node <= 105\nC++\nC++\nRun\n// C++ Program to print Bottom View of Binary Tree\n#include\nbits\nstdc\n++.\nusing\nnamespace\nstd\n// Tree node class\nstruct\nNode\nint\ndata\n//data of the node\nint\n//horizontal distance of the node\nNode\nleft\nright\n//left and right references\n// Constructor of tree node\nNode\nint\nkey\ndata\nkey\nINT_MAX\nleft\nright\nNULL\n// Method that prints the bottom view.\nvoid\nbottomView\nNode\nroot\nroot\nNULL\nreturn\n// Initialize a variable 'hd' with 0\n// for the root element.\nint\n// TreeMap which stores key value pair\n// sorted on key value\nmap\n// Queue to store tree nodes in level\n// order traversal\nqueue\n// Assign initialized horizontal distance\n// value to root node and add it to the queue.\nroot\npush\nroot\n// In STL, push() is used enqueue an item\n// Loop until the queue is empty (standard\n// level order loop)\nwhile\nempty\n())\nNode\ntemp\nfront\n();\npop\n();\n// In STL, pop() is used dequeue an item\n// Extract the horizontal distance value\n// from the dequeued tree node.\ntemp\n// Put the dequeued tree node to TreeMap\n// having key as horizontal distance. Every\n// time we find a node having same horizontal\n// distance we need to replace the data in\n// the map.\ntemp\ndata\n// If the dequeued node has a left child, add\n// it to the queue with a horizontal distance hd-1.\ntemp\nleft\nNULL\ntemp\nleft\npush\ntemp\nleft\n// If the dequeued node has a right child, add\n// it to the queue with a horizontal distance\n// hd+1.\ntemp\nright\nNULL\ntemp\nright\npush\ntemp\nright\n// Traverse the map elements using the iterator.\nfor\nauto\nbegin\n();\nend\n();\ncout\nsecond\n\" \"\n// Driver Code\nint\nmain\nNode\nroot\nnew\nNode\nroot\nleft\nnew\nNode\nroot\nright\nnew\nNode\nroot\nleft\nleft\nnew\nNode\nroot\nleft\nright\nnew\nNode\nroot\nright\nleft\nnew\nNode\nroot\nright\nright\nnew\nNode\nroot\nleft\nright\nleft\nnew\nNode\nroot\nleft\nright\nright\nnew\nNode\ncout\n\"Bottom view of the given binary tree :\\n\"\nbottomView\nroot\nreturn\nRun\n#include\n<stdio.h>\n#include\n<stdlib.h>\n#include\n<limits.h>\n// Tree node structure\ntypedef\nstruct\nNode\nint\ndata\n// Data of the node\nint\n// Horizontal distance of the node\nstruct\nNode\nleft\nright\n// Left and right references\nNode\n// Constructor of tree node\nNode\ncreateNode\nint\nkey\nNode\nnewNode\nNode\nmalloc\nsizeof\nNode\n));\nnewNode\ndata\nkey\nnewNode\nINT_MAX\nnewNode\nleft\nnewNode\nright\nNULL\nreturn\nnewNode\n// Linked list to store tree nodes in level order traversal\ntypedef\nstruct\nQueueNode\nNode\nnode\nstruct\nQueueNode\nnext\nQueueNode\n// Balanced Binary Search Tree to store key value pair\ntypedef\nstruct\nMapNode\nint\nkey\nint\nvalue\nstruct\nMapNode\nleft\nstruct\nMapNode\nright\nMapNode\n// Create a new MapNode and initialize its values\nMapNode\ncreateMapNode\nint\nkey\nint\nvalue\nMapNode\nnewMapNode\nMapNode\nmalloc\nsizeof\nMapNode\n));\nnewMapNode\nkey\nkey\nnewMapNode\nvalue\nvalue\nnewMapNode\nleft\nnewMapNode\nright\nNULL\nreturn\nnewMapNode\n// Insert a new MapNode into the balanced BST\nMapNode\ninsertMapNode\nMapNode\nnode\nint\nkey\nint\nvalue\nnode\nNULL\nreturn\ncreateMapNode\nkey\nvalue\nkey\nnode\nkey\nnode\nleft\ninsertMapNode\nnode\nleft\nkey\nvalue\nelse\nkey\nnode\nkey\nnode\nright\ninsertMapNode\nnode\nright\nkey\nvalue\nelse\n// Update the value for nodes with the same horizontal distance\nnode\nvalue\nvalue\nreturn\nnode\n// Enqueue a tree node to the queue\nvoid\nenqueue\nQueueNode\nfront\nQueueNode\nrear\nNode\nnode\nQueueNode\nnewQueueNode\nQueueNode\nmalloc\nsizeof\nQueueNode\n));\nnewQueueNode\nnode\nnode\nnewQueueNode\nnext\nNULL\nrear\nNULL\nfront\nrear\nnewQueueNode\nreturn\nrear\n)->\nnext\nnewQueueNode\nrear\nnewQueueNode\n// Dequeue a tree node from the queue\nNode\ndequeue\nQueueNode\nfront\nQueueNode\nrear\nfront\nNULL\nreturn\nNULL\nQueueNode\ntemp\nfront\nNode\nnode\ntemp\nnode\nfront\nfront\n)->\nnext\nfront\nNULL\nrear\nNULL\nfree\ntemp\nreturn\nnode\n// Method that prints the bottom view.\nvoid\nbottomView\nNode\nroot\nroot\nNULL\nreturn\n// Initialize a variable 'hd' with 0 for the root element.\nint\nQueueNode\nfront\nNULL\nQueueNode\nrear\nNULL\nMapNode\nrootMap\nNULL\n// Assign initialized horizontal distance value to root node and add it to the queue.\nroot\nenqueue\nfront\nrear\nroot\n// Loop until the queue is empty (standard level order loop)\nwhile\nfront\nNULL\nNode\ntemp\ndequeue\nfront\nrear\n// Extract the horizontal distance value from the dequeued tree node.\ntemp\n// Put the dequeued tree node to the balanced BST having key as horizontal distance.\n// Every time we find a node having the same horizontal distance, we need to replace the data in the BST.\nrootMap\ninsertMapNode\nrootMap\ntemp\ndata\n// If the dequeued node has a left child, add it to the queue with a horizontal distance hd-1.\ntemp\nleft\nNULL\ntemp\nleft\nenqueue\nfront\nrear\ntemp\nleft\n// If the dequeued node has a right child, add it to the queue with a horizontal distance hd+1.\ntemp\nright\nNULL\ntemp\nright\nenqueue\nfront\nrear\ntemp\nright\n// Traverse the map elements in order and print the values\nMapNode\ncurrentNode\nrootMap\nwhile\ncurrentNode\nNULL\nprintf\n\"%d \"\ncurrentNode\nvalue\ncurrentNode\ncurrentNode\nright\n// Driver Code\nint\nmain\nNode\nroot\ncreateNode\nroot\nleft\ncreateNode\nroot\nright\ncreateNode\nroot\nleft\nleft\ncreateNode\nroot\nleft\nright\ncreateNode\nroot\nright\nleft\ncreateNode\nroot\nright\nright\ncreateNode\nroot\nleft\nright\nleft\ncreateNode\nroot\nleft\nright\nright\ncreateNode\nprintf\n\"Bottom view of the given binary tree:\\n\"\nbottomView\nroot\nreturn\nQuestion 4\nAn expression is called the postfix expression if the operator appears in the expression after the operands.\nExample :\nInfix expression: A + B * C – D\nPostfix expression: A B + C D – *\nGiven a postfix expression, the task is to evaluate the expression. The answer could be very large, output your answer modulo (10^9+7). Also, use modular division when required.\nNote:\nOperators will only include the basic arithmetic operators like ‘*’, ‘/’, ‘+’, and ‘-‘.\nThe operand can contain multiple digits.\nThe operators and operands will have space as a separator between them.\nThere won’t be any brackets in the postfix expression.\nInput Format:\nThe first line of input contains an integer ‘T’ denoting the number of test cases.\nThe next ‘T’ lines represent the ‘T’ test cases.\nThe first and only line of each test case contains a postfix expression.\nOutput Format:\nThe first line of input contains an integer ‘T’ denoting the number of test cases.\nFor each test case, print an integer obtained by evaluating the given postfix expression.\nNote:\nYou are not required to print the expected output; it has already been taken care of, Just implement the function.\nConstraints\n1 <= T <= 100\n1 <= N <= 10^3\n1 <= NUM <= 100\nWhere ‘N’ denotes the length of postfix expression and ‘NUM’ denotes the operand.\nTime Limit: 1 sec\nSample input 1\n2 3 1 * + 9 –\n1 2 3 + * 8 –\nExplanation of sample input 1:\nSample output 1\nTest case 1:\n2 3 1 * + 9 –\n– : ( ) – ( )\n9 : ( ) – (9)\n+ : ( ( ) + ( ) ) – (9)\n‘*’: ( ( ) + ( ( ) * ( ) ) ) – (9)\n1 : ( ( ) + ( ( ) * (1) ) ) – (9)\n3 : ( ( ) + ( (3) * (1) ) ) – (9)\n2 : ( (2) + ( (3) * (1) ) ) – (9)\nResult = (2 + 3) – 9 = 5 – 9 = -4\nTest case 2\n1 2 3 + * 8 –\n– : ( ) – ( )\n8 : ( ) – (8)\n* : ( ( ) * ( ) ) – (8)\n+ : ( ( ) * ( ( ) + ( ) ) ) – (8)\n3 : ( ( ) * ( ( ) + (3) ) ) – (8)\n2 : ( ( ) * ( (2) + (3) ) ) – (8)\n1 : ( (1) * ( (2) + (3) ) ) – (8)\nResult = (1 * 5) – 8 = 5 – 8 = -3\nSample input 2\n100 200 + 2 / 5 * 7 +\nExplanation of sample input 2:\n100 + 200 = 300\n300 / 2 = 150\n150 * 5 = 750\n750 + 7 = 757\nSample output 2\n757\nC++\nC++\nRun\n// C++ program to evaluate value of a postfix expression\n#include\nbits\nstdc\n++.\nusing\nnamespace\nstd\n// The main function that returns value\n// of a given postfix expression\nint\nevaluatePostfix\nstring\nexp\n// Create a stack of capacity equal to expression size\nstack\nint\n// Scan all characters one by one\nfor\nint\nexp\nsize\n();\n// If the scanned character is an operand\n// (number here), push it to the stack.\nisdigit\nexp\n]))\npush\nexp\n'0'\n// If the scanned character is an operator,\n// pop two elements from stack apply the operator\nelse\nint\nval1\ntop\n();\npop\n();\nint\nval2\ntop\n();\npop\n();\nswitch\nexp\ncase\n'+'\npush\nval2\nval1\nbreak\ncase\n'-'\npush\nval2\nval1\nbreak\ncase\n'*'\npush\nval2\nval1\nbreak\ncase\n'/'\npush\nval2\nval1\nbreak\nreturn\ntop\n();\n// Driver code\nint\nmain\nint\nscanf\n\"%d\"\ngetchar\n();\nvector\nstring\nexpressions\nfor\nint\nchar\nexpression\n1005\nfgets\nexpression\nsizeof\nexpression\nstdin\nexpression\nstrcspn\nexpression\n\"\\n\"\n'\\0'\nexpressions\nexpression\nvector\nlong\nlong\nresults\nfor\nint\nresults\nevaluatePostfix\nexpressions\n]);\nfor\nint\nprintf\n\"%lld\\n\"\nresults\n]);\nreturn\nRun\n// C program to evaluate value of a postfix\n// expression having multiple digit operands\n#include\n<ctype.h>\n#include\n<stdio.h>\n#include\n<stdlib.h>\n#include\n<string.h>\n// Stack type\nstruct\nStack\nint\ntop\nunsigned\ncapacity\nint\narray\n// Stack Operations\nstruct\nStack\ncreateStack\nunsigned\ncapacity\nstruct\nStack\nstack\nstruct\nStack\nmalloc\nsizeof\nstruct\nStack\n));\nstack\nreturn\nNULL\nstack\ntop\nstack\ncapacity\ncapacity\nstack\narray\nint\nmalloc\nstack\ncapacity\nsizeof\nint\n));\nstack\narray\nreturn\nNULL\nreturn\nstack\nint\nisEmpty\nstruct\nStack\nstack\nreturn\nstack\ntop\nint\npeek\nstruct\nStack\nstack\nreturn\nstack\narray\nstack\ntop\nint\npop\nstruct\nStack\nstack\nisEmpty\nstack\nreturn\nstack\narray\nstack\ntop\n--];\nreturn\n'$'\nvoid\npush\nstruct\nStack\nstack\nint\nstack\narray\n[++\nstack\ntop\n// The main function that returns value\n// of a given postfix expression\nint\nevaluatePostfix\nchar\nexp\n// Create a stack of capacity equal to expression size\nstruct\nStack\nstack\ncreateStack\nstrlen\nexp\n));\nint\n// See if stack was created successfully\nstack\nreturn\n// Scan all characters one by one\nfor\nexp\n// if the character is blank space then continue\nexp\n' '\ncontinue\n// If the scanned character is an\n// operand (number here),extract the full number\n// Push it to the stack.\nelse\nisdigit\nexp\n]))\nint\nnum\n// extract full number\nwhile\nisdigit\nexp\n]))\nnum\nnum\nint\nexp\n'0'\n++;\n--;\n// push the element in the stack\npush\nstack\nnum\n// If the scanned character is an operator, pop two\n// elements from stack apply the operator\nelse\nint\nval1\npop\nstack\nint\nval2\npop\nstack\nswitch\nexp\ncase\n'+'\npush\nstack\nval2\nval1\nbreak\ncase\n'-'\npush\nstack\nval2\nval1\nbreak\ncase\n'*'\npush\nstack\nval2\nval1\nbreak\ncase\n'/'\npush\nstack\nval2\nval1\nbreak\nreturn\npop\nstack\n// Driver program to test above functions\nint\nmain\nchar\nexp\n\"100 200 + 2 / 5 * 7 +\"\n// Function call\nprintf\n\"%d\"\nevaluatePostfix\nexp\n));\nreturn\nQuestion 5\nAsked in Infosys Placment Paper – Feb 2022\nProblem Statement :\nYou are given a binary tree, the task is to find out the length of the longest path which contains nodes with the exact same value. It is not necessary for the path to pass through the root of the binary tree.\nBetween two nodes, the length of the path can be defined as the number of edges contained between them.\nFor example, consider the following binary tree:\n/ \\\n7 7\n/ \\ \\\n8 3 7\nFor the above tree, the length of the longest path where each node in the path has the same value is 3 and path is 7 -> 7 -> 7 -> 7\nInput format:\nThe first line of input contains an integer ‘T’ representing the number of test cases. Then the test cases follow.\nThe only line of each test case contains elements in the level order form. The line consists of values of nodes separated by a single space. In case a node is null, we take -1 on its place.\nFor example, the input for the tree depicted in the below image would be:\n2 3\n4 -1 5 6\n-1 7 -1 -1 -1 -1\n-1 -1\nExplanation:\nLevel 1:\nThe root node of the tree is 1\nLevel 2:\nLeft child of 1 = 2\nRight child of 1 = 3\nLevel 3:\nLeft child of 2 = 4\nRight child of 2 = null (-1)\nLeft child of 3 = 5\nRight child of 3 = 6\nLevel 4:\nLeft child of 4 = null (-1)\nRight child of 4 = 7\nLeft child of 5 = null (-1)\nRight child of 5 = null (-1)\nLeft child of 6 = null (-1)\nRight child of 6 = null (-1)\nLevel 5:\nLeft child of 7 = null (-1)\nRight child of 7 = null (-1)\nThe first not-null node(of the previous level) is treated as the parent of the first two nodes of the current level. The second not-null node (of the previous level) is treated as the parent node for the next two nodes of the current level and so on.\nThe input ends when all nodes at the last level are null(-1).\nNote:\nThe above format was just to provide clarity on how the input is formed for a given tree.\nThe sequence will be put together in a single line separated by a single space. Hence, for the above-depicted tree, the input will be given as:\n1 2 3 4 -1 5 6 -1 7 -1 -1 -1 -1 -1 -1\nOutput Format:\nFor each test case, a single integer denoting the length of the longest path where each node in the path has the same value is printed.\nThe output for each test case is to be printed on a separate line.\nNote:\nYou do not need to print anything; it has already been taken care of. Just implement the given function.\nConstraints:\n1 <= T <= 100\n1 <= N <= 3000\n-10^9 <= data <= 10^9 and data != -1\nWhere ‘T’ is the number of test cases, ‘N’ is the total number of nodes in the binary tree, and “data” is the value of the binary tree node.\nTime Limit\n: 1sec\nSample Input 1:\n7 7 7 1 1 -1 7 -1 -1 -1 -1 -1 -1\n10 3 4 3 3 -1 5 -1 -1 -1 -1 -1 -1\nSample Output 1:\nSample Input 2:\n1 4 5 4 4 -1 5 -1 -1 -1 -1 -1 -1\n5 4 5 1 1 -1 5 -1 -1 -1 -1 -1 -1\nSample Output 2:\nExplanation of Sample Input 1:\n/ \\\n7 7\n/ \\ \\\n1 1 7\nFor the first test case, the length of the longest path where each node in the path has the same value is 3 and path is 7 -> 7 -> 7 -> 7.\n/ \\\n3 4\n/ \\ \\\n3 3 5\nFor the second test case, the length of the longest path where each node in the path has the same value is 2 and path is 3 -> 3 -> 3.\nJava\nC++\nJava\nRun\nclass\nMain\nstatic\nclass\nNode\nint\nval\nNode\nleft\nright\nstatic\nNode\nnewNode\nint\ndata\nNode\ntemp\nnew\nNode\n();\ntemp\nval\ndata\ntemp\nleft\ntemp\nright\nnull\nreturn\ntemp\npublic\nstatic\nvoid\nmain\nString\nargs\nNode\nroot\nnull\nroot\nnewNode\nroot\nleft\nnewNode\nroot\nright\nnewNode\nroot\nleft\nleft\nnewNode\nroot\nleft\nright\nnewNode\nroot\nright\nright\nnewNode\nSystem\nout\nprint\nlongestSamevaluePath\nroot\n));\nstatic\nint\nres\npublic\nstatic\nint\nlongestSamevaluePath\nNode\nroot\nroot\nnull\nreturn\nsolve\nroot\nreturn\nres\npublic\nstatic\nint\nsolve\nNode\nroot\nroot\nnull\nreturn\nint\nlHeight\nsolve\nroot\nleft\nint\nrHeight\nsolve\nroot\nright\nint\nlchk\nint\nrchk\nroot\nleft\nnull\nroot\nleft\nval\nroot\nval\nlchk\nlHeight\nroot\nright\nnull\nroot\nright\nval\nroot\nval\nrchk\nrHeight\nres\nMath\nmax\nres\nlchk\nrchk\nreturn\nMath\nmax\nlchk\nrchk\nC++\nRun\n#include\n<iostream>\nusing\nnamespace\nstd\nclass\nNode\npublic\nint\nval\nNode\nleft\nNode\nright\nNode\nnewNode\nint\ndata\nNode\ntemp\nnew\nNode\n();\ntemp\nval\ndata\ntemp\nleft\ntemp\nright\nnullptr\nreturn\ntemp\nint\nres\nint\nsolve\nNode\nroot\nroot\nnullptr\nreturn\nint\nlHeight\nsolve\nroot\nleft\nint\nrHeight\nsolve\nroot\nright\nint\nlchk\nint\nrchk\nroot\nleft\nnullptr\nroot\nleft\nval\nroot\nval\nlchk\nlHeight\nroot\nright\nnullptr\nroot\nright\nval\nroot\nval\nrchk\nrHeight\nres\nmax\nres\nlchk\nrchk\nreturn\nmax\nlchk\nrchk\nint\nlongestSamevaluePath\nNode\nroot\nroot\nnullptr\nreturn\nsolve\nroot\nreturn\nres\nint\nmain\nNode\nroot\nnullptr\nroot\nnewNode\nroot\nleft\nnewNode\nroot\nright\nnewNode\nroot\nleft\nleft\nnewNode\nroot\nleft\nright\nnewNode\nroot\nright\nright\nnewNode\ncout\nlongestSamevaluePath\nroot\nendl\nreturn\nRun\n#include\n<stdio.h>\n#include\n<stdlib.h>\nstruct\nNode\nint\nval\nstruct\nNode\nleft\nstruct\nNode\nright\nstruct\nNode\nnewNode\nint\ndata\nstruct\nNode\ntemp\nstruct\nNode\nmalloc\nsizeof\nstruct\nNode\n));\ntemp\nval\ndata\ntemp\nleft\ntemp\nright\nNULL\nreturn\ntemp\nint\nres\nint\nsolve\nstruct\nNode\nroot\nroot\nNULL\nreturn\nint\nlHeight\nsolve\nroot\nleft\nint\nrHeight\nsolve\nroot\nright\nint\nlchk\nint\nrchk\nroot\nleft\nNULL\nroot\nleft\nval\nroot\nval\nlchk\nlHeight\nroot\nright\nNULL\nroot\nright\nval\nroot\nval\nrchk\nrHeight\nres\nres\nlchk\nrchk\nres\nlchk\nrchk\nreturn\nlchk\nrchk\nlchk\nrchk\nint\nlongestSamevaluePath\nstruct\nNode\nroot\nroot\nNULL\nreturn\nsolve\nroot\nreturn\nres\nint\nmain\nstruct\nNode\nroot\nNULL\nroot\nnewNode\nroot\nleft\nnewNode\nroot\nright\nnewNode\nroot\nleft\nleft\nnewNode\nroot\nleft\nright\nnewNode\nroot\nright\nright\nnewNode\nprintf\n\"%d\\n\"\nlongestSamevaluePath\nroot\n));\nreturn\nGet over 200+ course One Subscription\nCourses like AI/ML, Cloud Computing, Ethical Hacking, C, C++, Java, Python, DSA (All Languages), Competitive Coding (All Languages), TCS, Infosys, Wipro, Amazon, DBMS, SQL and others\nGet Prime\nCourse List\nCourse List\nCheckout list of all the video courses in PrepInsta Prime Subscription\nCheckout list of all the video courses in PrepInsta Prime Subscription\nCheckout\nCheckout\nLogin/Signup\nto comment\n30+ Companies are Hiring\nGet Hiring Updates right in your inbox from PrepInsta"
  },
  "qa": {
    "GeeksforGeeks": [],
    "InterviewBit": [
      {
        "question": "What will you Learn?",
        "answer": "I wish to receive further updates and confirmation via whatsapp Register Now About Amazon Earth's most 'Customer Centric' company, Amazon was founded by Jeff Bezos from his garage in Bellevue, Washington on July 5, 1994. Amazon is an American multinational technology company whose focus is on a large number of fields, for instance, E-Commerce, Cloud Computing, Artificial Intelligence, Digital Streaming, etcetera. It is considered to be one of the Big Five companies in the United States Information Technology industry, along with Google, Apple, Microsoft, and Facebook. Amazon is renowned for its huge disruption of industries through technological innovation and mass scale. Being the world's largest online marketplace, AI assistant provider, and cloud computing platform, Amazon has a workforce of over six lakh employees, out of which over fifty thousand are Indians. It is the largest Internet company by revenue in the world right now and the second-largest private employer in the United States. Because of this, Amazon has the highest global brand valuation. Given the plethora of services that Amazon offers, it is pretty obvious that a lot of people want to join Amazon and be part of its evergreen culture. But what really is the secret sauce to Amazon’s humongous success? Well, if you ask this question to any of the employees at Amazon, we are pretty sure that everyone would unanimously say: 'The Leadership Principles of Amazon' Play Amazon Interview Preparation"
      },
      {
        "question": "1. Interview Preparation Tips",
        "answer": "Now that we know about the rich heritage of Amazon, its work culture, and its Leadership Principles, I am sure that you will be tempted to interview at Amazon and take a job! Here are a few tips which you can use to crack Amazon's interview and get a job Understand the Leadership Principles Well - As mentioned before, Amazonians take great pride as far as their Leadership Principles are concerned. Therefore, knowing about these principles and citing an instance or two where the candidate has applied them in real life will have a positive impact on the interviewers. This leaves an impression that the candidate is genuinely interested in working with the company. Be Thorough with Data Structures and Algorithms - At Amazon, there is always an appreciation for great problem solvers. If you want to have a good impression of the interviewers, the best way is to prove that you have worked a lot on developing your logic structures and solving algorithmic problems. A good understanding of Data Structures and Algorithms and having one or two good projects always earn you brownie points with Amazon. Use the STAR method to format your Response - STAR is an acronym for Situation, Task, Action, and Result. The STAR method is a structured way to respond to behavioral-based interview questions. To answer a provided question using the STAR method, you start by describing the situation that was at hand, the Task which needed to be done, the action taken by you as a response to the Task, and finally the Result of the experience. It is important to think about all the details and recall everyone and everything that was involved in the situation. Let the interviewer know how much of an impact that experience had on your life and in the lives of all others who were involved. It is always good practice to be prepared with a real-life story that you can describe using the STAR method. Know and Describe your Strengths - Many people who interview at various companies, stay shy during the interviews and feel uncomfortable when they are asked to describe their strengths. Remember that if you do not show how good you are at the skills you know, no one will ever be able to know about the same and this might just cost you a lot. So it is okay to think about yourself and highlight your strengths properly and honestly as and when required. Discuss with your interviewer and keep the conversation going - Remember that an interview is not a written exam and therefore even if you come up with the best of solutions for the given problems, it is not worth anything until and unless the interviewer understands what you are trying to say. Therefore, it is important to make the interviewer that he or she is also a part of the interview. Also, asking questions might always prove to be helpful during the interview. Create a free personalised study plan Create a FREE custom study plan Get into your dream companies with expert guidance Get into your dream companies with expert.. Real-Life Problems Prep for Target Roles Custom Plan Duration Flexible Plans Create My Plan Amazon Recruitment Process"
      },
      {
        "question": "1. Interview Process",
        "answer": "Recruiter Connect: Best way to get noticed by Amazon recruiters is to maintain a good Linkedin profile and message recruiters. The candidate can also apply on the Amazon job portal but it is suggested that they also get a referral from an Amazon employee. Interview Rounds : Amazon conducts four interview rounds alongside an initial coding test. The coding test consists of DS/Algo problems. The first round is an HR round where they ask behavioral questions along with Computer Science theory questions to the candidate. The next three rounds focus solely on DS/Algo. After Interviews: The recruiter contacts the candidate after these rounds and tells the verdict. They also look at the candidate’s leadership principles along with technical skills. Hired: Once the team and you both are comfortable and ready to start, the offer letter is prepared and shared with you by the recruiters and you are HIRED!"
      },
      {
        "question": "2. Interview Rounds",
        "answer": "HR Round(1 Round): This is when they ask computer science theory and behavioural questions to the candidate. The questions may enquire about the candidate’s experience at previous companies and conflicts the candidate might have faced with colleagues/managers. Data Structures and Algorithms Rounds(3 Rounds): The candidate is asked DS/Algo problems where production ready code might be expected from the candidate. It is not out of the realm of possibility to face minor behavioural questions here as well. The problems range from easy to hard but they are not the sole deciding factor for the final offer. Leadership principles also come into play here. The interviews are conducted on Amazon Chime. You can download a PDF version of Amazon Interview Questions. Download PDF Download PDF Download PDF Your requested download is ready! Click here to download. Frequently Asked Questions"
      },
      {
        "question": "1. What are the Amazon interview rounds?",
        "answer": "There are 5 rounds (4- Data Structures and Algorithms, 1- System Design, and 1- HR) at Amazon."
      },
      {
        "question": "2. Are Amazon interviews hard?",
        "answer": "The toughness of an interview depends upon the amount of hard work you have put in to prepare for them. Usually, the questions asked in a standard Amazon interview are of Easy to Medium Level but it varies from person to person. Learn via our Video Courses"
      },
      {
        "question": "3. How do I apply for a job at Amazon?",
        "answer": "You can go to the Amazon Jobs portal and apply for any open role matching your skill set over there."
      },
      {
        "question": "4. Can I apply for multiple roles at Amazon?",
        "answer": "Yes, we can apply to any role that aligns with both our interests and skills. We are evaluated against the requirements for each role and we can give interviews for different roles at the same time. Advance your career with Mock Assessments Refine your coding skills with Mock Assessments Real-world coding challenges for top company interviews Real-world coding challenges for top companies Real-Life Problems Detailed reports Attempt Now"
      },
      {
        "question": "5. What are some of the questions which one should ask the interviewer at Amazon?",
        "answer": "It is always nice to ask questions about the company's culture and what is the current technology using which the company makes its products. Asking about the future innovations at Amazon also might be a good idea as it might make the interviewer believe that you are looking forward to joining Amazon for a long time. You can also ask about the interviewer's personal experience at Amazon and what skills you must develop before you join the job."
      },
      {
        "question": "6. How to prepare for the coding interviews at Amazon?",
        "answer": "The secret lies in the amount of practice you do. Put in a lot of effort in solving challenging problems on Data Structures and Algorithms. Having a good knowledge of fundamental Computer Science Concepts like Object-Oriented Programming, Computer Networks, Operating Systems, etc. might also be helpful."
      },
      {
        "question": "7. Does Amazon have a dress code?",
        "answer": "No, Amazon does not have a dress code. However, all employees are supposed to wear decent clothes at their respective places of work."
      },
      {
        "question": "8. Is having a project on Web or Android Development or Machine Learning a must for being hired at Amazon?",
        "answer": "No, only good problem-solving skills are required to get hired at Amazon for an SDE position. Having said that, you will always get brownie points if you have a good project or two in your Resume as it shows that you are referenced and interested in the domain on which you have made your project. Coding Problems 0/4 Easy Problems Greedy Algorithm Dynamic Programming Majority Element Easy"
      },
      {
        "question": "19.7 Mins",
        "answer": "Solve Unique Binary Search Trees Easy"
      },
      {
        "question": "62.0 Mins",
        "answer": "Solve Best Time to Buy and Sell Stocks II Easy"
      },
      {
        "question": "40.18 Mins",
        "answer": "Solve Best Time to Buy and Sell Stocks I Easy"
      },
      {
        "question": "28.13 Mins",
        "answer": "Solve 0/5 Intermediate Problems Greedy Algorithm Dynamic Programming Gas Station Medium"
      },
      {
        "question": "56.42 Mins",
        "answer": "Solve Distribute Candy Medium"
      },
      {
        "question": "65.48 Mins",
        "answer": "Solve Longest Increasing Subsequence Medium"
      },
      {
        "question": "30.39 Mins",
        "answer": "Solve Max Product Subarray Medium"
      },
      {
        "question": "65.25 Mins",
        "answer": "Solve Ways to Decode Medium"
      },
      {
        "question": "70.8 Mins",
        "answer": "Solve 0/1 Advanced Problems Dynamic Programming Best Time to Buy and Sell Stocks III Hard"
      },
      {
        "question": "64.56 Mins",
        "answer": "Solve View All Problems Excel at your interview with Masterclasses Know More Certificate included"
      },
      {
        "question": "What will you Learn?",
        "answer": "I wish to receive further updates and confirmation via whatsapp Register Now For FREE! Powered By You Have Successfully registered! Join our WhatsApp group for free learning material and session link."
      }
    ],
    "PrepInsta": [
      {
        "question": "Question 3",
        "answer": "Prime Course Trailer Related Banners Get PrepInsta Prime & get Access to all 200+ courses offered by PrepInsta in One Subscription Get Prime"
      },
      {
        "question": "Question 1",
        "answer": "Problem Statement: Check if strings are rotations of each other or not Given two strings s1 and s2. The task is to check if s2 is a rotated version of the string s1. The characters in the strings are in lowercase. Test Case 1: Input: mightandmagic andmagicmigth Output: Explanation: Here with any amount of rotation s2 can’t be obtained by s1. Your Task: The task is to complete the function areRotations() which checks if the two strings are rotations of each other. The function returns true if string 1 can be obtained by rotating string 2, else it returns false. Expected Time Complexity: O(N). Expected Space Complexity: O(N). Note: N = |s1|. Constraints: 1 <= |s1|, |s2| <= 107 Java C++ Java Run import java util .*; public class Main public static void main String args Scanner new Scanner System int nextInt (); int price new int for int i diff new Vector (); for int --) diff add price price ]);} int ans solve diff ans System out println );} else System out println ans );} private static int solve Vector int size (); return int get for int ++) Math max get ));} return int mxSum csum for int ++) csum get csum csum mxSum Math max csum mxSum );} return mxSum C++ Run #include bits stdc ++. using namespace std class Main public bool Rotation string string int size int size return false string temp temp find return false int main int cin while --) string string cin Solution obj cout obj Rotation )<< endl return Run #include <stdio.h> #include <string.h> int areRotations char char int len1 strlen int len2 strlen len1 len2 return char temp 200 strcpy temp strcat temp strstr temp return return int main char 100 100 printf \"Enter string 1: \" scanf \"%s\" printf \"Enter string 2: \" scanf \"%s\" int result areRotations result printf \"1\\n\" else printf \"0\\n\" return"
      },
      {
        "question": "Question 2",
        "answer": "Problem Statement: Jarvis is weak in computing palindromes for Alphanumeric characters. While Ironman is busy fighting Thanos, he needs to activate sonic punch but Jarvis is stuck in computing palindromes. You are given a string containing alphanumeric characters. Find out whether the string is a palindrome or not. If you are unable to solve it then it may result in the death of Iron Man. Test Case 1:- Input: S = “I am :IronnorI Ma, i” Output: YES Explanation: Ignore all the symbols and whitespaces S = “IamIronnorIMai”. Now, Check for palindrome ignoring uppercase and lowercase English letter. Test Case 2:- Input: S = Ab?/Ba Output: YES Explanation: Here with any amount of rotation s2 can’t be obtained by s1. Your Task: This is a function problem. The input is already taken care of by the driver code. You only need to complete the function saveIronman() that takes an string (ch) , and return the true if the string is a palindrome and false if the string is not a palindrome. The driver code takes care of the printing. Expected Time Complexity: O(N). Expected Space Complexity: O(1). Note: N = |s1|. Constraints: 1 ≤ |S| ≤ 100000 Note: Consider alphabets and numbers only for palindrome check. Ignore symbols and whitespaces. Java C++ Java Run import java util .*; import java lang .*; import java .*; class Main public static void main String args throws Exception BufferedReader new BufferedReader new InputStreamReader System )); String readLine (); toLowerCase (); replaceAll \" [,?/:;!]\" char toCharArray (); int int length boolean check true while check false ++; continue check false --; continue ])) check false break ++; --; check System out println \"YES\" else System out println \"NO\" public static boolean check char boolean false byte byte 122 return true else '1' '2' '3' '4' '5' '6' '7' '8' '9' '0' return true return C++ Run #include <iostream> #include <cctype> #include <string> using namespace std bool isPalindrome const string str int str length while // Skip symbols and whitespaces while isalnum str ++; while isalnum str --; // Convert characters to lowercase for comparison char left tolower str ]); char right tolower str ]); left right return false ++; --; return true int main string str getline cin str // Read input string with spaces isPalindrome str cout \"YES\\n\" else cout \"NO\\n\" return Run #include <stdio.h> #include <ctype.h> #include <stdbool.h> bool isPalindrome char [], int len int len while // Skip symbols and whitespaces while isalnum ++; while isalnum --; // Convert characters to lowercase for comparison char left tolower ]); char right tolower ]); left right return false ++; --; return true int main char 100001 scanf \" %[^\\n]s\" // Read input string with spaces int len for int '\\0' ++) len ++; isPalindrome len printf \"YES\\n\" else printf \"NO\\n\" return"
      },
      {
        "question": "Question 3",
        "answer": "Problem Statement: Given a binary tree, print the bottom view from left to right. A node is included in bottom view if it can be seen when we look at the tree from bottom. / \\ 5 3 / \\ For the above tree, the bottom view is 5 10 3 14 25. If there are multiple bottom-most nodes for a horizontal distance from root, then print the later one in level traversal. For example, in the below diagram, 3 and 4 are both the bottommost nodes at horizontal distance 0, we need to print 4. / \\ / \\ 5 3 4 25 / \\ 10 14 For the above tree the output should be 5 10 4 14 25. Example 1: Input: / \\ 3 2 Output: 3 1 2 Explanation: First case represents a tree with 3 nodes and 2 edges where root is 1, left child of 1 is 3 and right child of 1 is 2. Example 2: Input: / \\ 20 30 / \\ 40 60 Output: 40 20 60 30 Your Task: This is a functional problem, you don’t need to care about input, just complete the function bottomView () which takes the root node of the tree as input and returns an array containing the bottom view of the given tree. Expected Time Complexity: O(N). Expected Auxiliary Space: O(N). Constraints: 1 <= Number of nodes <= 105 1 <= Data of a node <= 105 C++ C++ Run // C++ Program to print Bottom View of Binary Tree #include bits stdc ++. using namespace std // Tree node class struct Node int data //data of the node int //horizontal distance of the node Node left right //left and right references // Constructor of tree node Node int key data key INT_MAX left right NULL // Method that prints the bottom view. void bottomView Node root root NULL return // Initialize a variable 'hd' with 0 // for the root element. int // TreeMap which stores key value pair // sorted on key value map // Queue to store tree nodes in level // order traversal queue // Assign initialized horizontal distance // value to root node and add it to the queue. root push root // In STL, push() is used enqueue an item // Loop until the queue is empty (standard // level order loop) while empty ()) Node temp front (); pop (); // In STL, pop() is used dequeue an item // Extract the horizontal distance value // from the dequeued tree node. temp // Put the dequeued tree node to TreeMap // having key as horizontal distance. Every // time we find a node having same horizontal // distance we need to replace the data in // the map. temp data // If the dequeued node has a left child, add // it to the queue with a horizontal distance hd-1. temp left NULL temp left push temp left // If the dequeued node has a right child, add // it to the queue with a horizontal distance // hd+1. temp right NULL temp right push temp right // Traverse the map elements using the iterator. for auto begin (); end (); cout second \" \" // Driver Code int main Node root new Node root left new Node root right new Node root left left new Node root left right new Node root right left new Node root right right new Node root left right left new Node root left right right new Node cout \"Bottom view of the given binary tree :\\n\" bottomView root return Run #include <stdio.h> #include <stdlib.h> #include <limits.h> // Tree node structure typedef struct Node int data // Data of the node int // Horizontal distance of the node struct Node left right // Left and right references Node // Constructor of tree node Node createNode int key Node newNode Node malloc sizeof Node )); newNode data key newNode INT_MAX newNode left newNode right NULL return newNode // Linked list to store tree nodes in level order traversal typedef struct QueueNode Node node struct QueueNode next QueueNode // Balanced Binary Search Tree to store key value pair typedef struct MapNode int key int value struct MapNode left struct MapNode right MapNode // Create a new MapNode and initialize its values MapNode createMapNode int key int value MapNode newMapNode MapNode malloc sizeof MapNode )); newMapNode key key newMapNode value value newMapNode left newMapNode right NULL return newMapNode // Insert a new MapNode into the balanced BST MapNode insertMapNode MapNode node int key int value node NULL return createMapNode key value key node key node left insertMapNode node left key value else key node key node right insertMapNode node right key value else // Update the value for nodes with the same horizontal distance node value value return node // Enqueue a tree node to the queue void enqueue QueueNode front QueueNode rear Node node QueueNode newQueueNode QueueNode malloc sizeof QueueNode )); newQueueNode node node newQueueNode next NULL rear NULL front rear newQueueNode return rear )-> next newQueueNode rear newQueueNode // Dequeue a tree node from the queue Node dequeue QueueNode front QueueNode rear front NULL return NULL QueueNode temp front Node node temp node front front )-> next front NULL rear NULL free temp return node // Method that prints the bottom view. void bottomView Node root root NULL return // Initialize a variable 'hd' with 0 for the root element. int QueueNode front NULL QueueNode rear NULL MapNode rootMap NULL // Assign initialized horizontal distance value to root node and add it to the queue. root enqueue front rear root // Loop until the queue is empty (standard level order loop) while front NULL Node temp dequeue front rear // Extract the horizontal distance value from the dequeued tree node. temp // Put the dequeued tree node to the balanced BST having key as horizontal distance. // Every time we find a node having the same horizontal distance, we need to replace the data in the BST. rootMap insertMapNode rootMap temp data // If the dequeued node has a left child, add it to the queue with a horizontal distance hd-1. temp left NULL temp left enqueue front rear temp left // If the dequeued node has a right child, add it to the queue with a horizontal distance hd+1. temp right NULL temp right enqueue front rear temp right // Traverse the map elements in order and print the values MapNode currentNode rootMap while currentNode NULL printf \"%d \" currentNode value currentNode currentNode right // Driver Code int main Node root createNode root left createNode root right createNode root left left createNode root left right createNode root right left createNode root right right createNode root left right left createNode root left right right createNode printf \"Bottom view of the given binary tree:\\n\" bottomView root return"
      },
      {
        "question": "Question 4",
        "answer": "An expression is called the postfix expression if the operator appears in the expression after the operands. Example : Infix expression: A + B * C – D Postfix expression: A B + C D – * Given a postfix expression, the task is to evaluate the expression. The answer could be very large, output your answer modulo (10^9+7). Also, use modular division when required. Note: Operators will only include the basic arithmetic operators like ‘*’, ‘/’, ‘+’, and ‘-‘. The operand can contain multiple digits. The operators and operands will have space as a separator between them. There won’t be any brackets in the postfix expression. Input Format: The first line of input contains an integer ‘T’ denoting the number of test cases. The next ‘T’ lines represent the ‘T’ test cases. The first and only line of each test case contains a postfix expression. Output Format: The first line of input contains an integer ‘T’ denoting the number of test cases. For each test case, print an integer obtained by evaluating the given postfix expression. Note: You are not required to print the expected output; it has already been taken care of, Just implement the function. Constraints 1 <= T <= 100 1 <= N <= 10^3 1 <= NUM <= 100 Where ‘N’ denotes the length of postfix expression and ‘NUM’ denotes the operand. Time Limit: 1 sec Sample input 1 2 3 1 * + 9 – 1 2 3 + * 8 – Explanation of sample input 1: Sample output 1 Test case 1: 2 3 1 * + 9 – – : ( ) – ( ) 9 : ( ) – (9) + : ( ( ) + ( ) ) – (9) ‘*’: ( ( ) + ( ( ) * ( ) ) ) – (9) 1 : ( ( ) + ( ( ) * (1) ) ) – (9) 3 : ( ( ) + ( (3) * (1) ) ) – (9) 2 : ( (2) + ( (3) * (1) ) ) – (9) Result = (2 + 3) – 9 = 5 – 9 = -4 Test case 2 1 2 3 + * 8 – – : ( ) – ( ) 8 : ( ) – (8) * : ( ( ) * ( ) ) – (8) + : ( ( ) * ( ( ) + ( ) ) ) – (8) 3 : ( ( ) * ( ( ) + (3) ) ) – (8) 2 : ( ( ) * ( (2) + (3) ) ) – (8) 1 : ( (1) * ( (2) + (3) ) ) – (8) Result = (1 * 5) – 8 = 5 – 8 = -3 Sample input 2 100 200 + 2 / 5 * 7 + Explanation of sample input 2: 100 + 200 = 300 300 / 2 = 150 150 * 5 = 750 750 + 7 = 757 Sample output 2 757 C++ C++ Run // C++ program to evaluate value of a postfix expression #include bits stdc ++. using namespace std // The main function that returns value // of a given postfix expression int evaluatePostfix string exp // Create a stack of capacity equal to expression size stack int // Scan all characters one by one for int exp size (); // If the scanned character is an operand // (number here), push it to the stack. isdigit exp ])) push exp '0' // If the scanned character is an operator, // pop two elements from stack apply the operator else int val1 top (); pop (); int val2 top (); pop (); switch exp case '+' push val2 val1 break case '-' push val2 val1 break case '*' push val2 val1 break case '/' push val2 val1 break return top (); // Driver code int main int scanf \"%d\" getchar (); vector string expressions for int char expression 1005 fgets expression sizeof expression stdin expression strcspn expression \"\\n\" '\\0' expressions expression vector long long results for int results evaluatePostfix expressions ]); for int printf \"%lld\\n\" results ]); return Run // C program to evaluate value of a postfix // expression having multiple digit operands #include <ctype.h> #include <stdio.h> #include <stdlib.h> #include <string.h> // Stack type struct Stack int top unsigned capacity int array // Stack Operations struct Stack createStack unsigned capacity struct Stack stack struct Stack malloc sizeof struct Stack )); stack return NULL stack top stack capacity capacity stack array int malloc stack capacity sizeof int )); stack array return NULL return stack int isEmpty struct Stack stack return stack top int peek struct Stack stack return stack array stack top int pop struct Stack stack isEmpty stack return stack array stack top --]; return '$' void push struct Stack stack int stack array [++ stack top // The main function that returns value // of a given postfix expression int evaluatePostfix char exp // Create a stack of capacity equal to expression size struct Stack stack createStack strlen exp )); int // See if stack was created successfully stack return // Scan all characters one by one for exp // if the character is blank space then continue exp ' ' continue // If the scanned character is an // operand (number here),extract the full number // Push it to the stack. else isdigit exp ])) int num // extract full number while isdigit exp ])) num num int exp '0' ++; --; // push the element in the stack push stack num // If the scanned character is an operator, pop two // elements from stack apply the operator else int val1 pop stack int val2 pop stack switch exp case '+' push stack val2 val1 break case '-' push stack val2 val1 break case '*' push stack val2 val1 break case '/' push stack val2 val1 break return pop stack // Driver program to test above functions int main char exp \"100 200 + 2 / 5 * 7 +\" // Function call printf \"%d\" evaluatePostfix exp )); return"
      },
      {
        "question": "Question 5",
        "answer": "Asked in Infosys Placment Paper – Feb 2022 Problem Statement : You are given a binary tree, the task is to find out the length of the longest path which contains nodes with the exact same value. It is not necessary for the path to pass through the root of the binary tree. Between two nodes, the length of the path can be defined as the number of edges contained between them. For example, consider the following binary tree: / \\ 7 7 / \\ \\ 8 3 7 For the above tree, the length of the longest path where each node in the path has the same value is 3 and path is 7 -> 7 -> 7 -> 7 Input format: The first line of input contains an integer ‘T’ representing the number of test cases. Then the test cases follow. The only line of each test case contains elements in the level order form. The line consists of values of nodes separated by a single space. In case a node is null, we take -1 on its place. For example, the input for the tree depicted in the below image would be: 2 3"
      },
      {
        "question": "4 -1 5 6",
        "answer": "-1 7 -1 -1 -1 -1 -1 -1 Explanation: Level 1: The root node of the tree is 1 Level 2: Left child of 1 = 2 Right child of 1 = 3 Level 3: Left child of 2 = 4 Right child of 2 = null (-1) Left child of 3 = 5 Right child of 3 = 6 Level 4: Left child of 4 = null (-1) Right child of 4 = 7 Left child of 5 = null (-1) Right child of 5 = null (-1) Left child of 6 = null (-1) Right child of 6 = null (-1) Level 5: Left child of 7 = null (-1) Right child of 7 = null (-1) The first not-null node(of the previous level) is treated as the parent of the first two nodes of the current level. The second not-null node (of the previous level) is treated as the parent node for the next two nodes of the current level and so on. The input ends when all nodes at the last level are null(-1). Note: The above format was just to provide clarity on how the input is formed for a given tree. The sequence will be put together in a single line separated by a single space. Hence, for the above-depicted tree, the input will be given as: 1 2 3 4 -1 5 6 -1 7 -1 -1 -1 -1 -1 -1 Output Format: For each test case, a single integer denoting the length of the longest path where each node in the path has the same value is printed. The output for each test case is to be printed on a separate line. Note: You do not need to print anything; it has already been taken care of. Just implement the given function. Constraints: 1 <= T <= 100 1 <= N <= 3000 -10^9 <= data <= 10^9 and data != -1 Where ‘T’ is the number of test cases, ‘N’ is the total number of nodes in the binary tree, and “data” is the value of the binary tree node. Time Limit : 1sec Sample Input 1: 7 7 7 1 1 -1 7 -1 -1 -1 -1 -1 -1 10 3 4 3 3 -1 5 -1 -1 -1 -1 -1 -1 Sample Output 1: Sample Input 2: 1 4 5 4 4 -1 5 -1 -1 -1 -1 -1 -1 5 4 5 1 1 -1 5 -1 -1 -1 -1 -1 -1 Sample Output 2: Explanation of Sample Input 1: / \\ 7 7 / \\ \\ 1 1 7 For the first test case, the length of the longest path where each node in the path has the same value is 3 and path is 7 -> 7 -> 7 -> 7. / \\ 3 4 / \\ \\ 3 3 5 For the second test case, the length of the longest path where each node in the path has the same value is 2 and path is 3 -> 3 -> 3. Java C++ Java Run class Main static class Node int val Node left right static Node newNode int data Node temp new Node (); temp val data temp left temp right null return temp public static void main String args Node root null root newNode root left newNode root right newNode root left left newNode root left right newNode root right right newNode System out print longestSamevaluePath root )); static int res public static int longestSamevaluePath Node root root null return solve root return res public static int solve Node root root null return int lHeight solve root left int rHeight solve root right int lchk int rchk root left null root left val root val lchk lHeight root right null root right val root val rchk rHeight res Math max res lchk rchk return Math max lchk rchk C++ Run #include <iostream> using namespace std class Node public int val Node left Node right Node newNode int data Node temp new Node (); temp val data temp left temp right nullptr return temp int res int solve Node root root nullptr return int lHeight solve root left int rHeight solve root right int lchk int rchk root left nullptr root left val root val lchk lHeight root right nullptr root right val root val rchk rHeight res max res lchk rchk return max lchk rchk int longestSamevaluePath Node root root nullptr return solve root return res int main Node root nullptr root newNode root left newNode root right newNode root left left newNode root left right newNode root right right newNode cout longestSamevaluePath root endl return Run #include <stdio.h> #include <stdlib.h> struct Node int val struct Node left struct Node right struct Node newNode int data struct Node temp struct Node malloc sizeof struct Node )); temp val data temp left temp right NULL return temp int res int solve struct Node root root NULL return int lHeight solve root left int rHeight solve root right int lchk int rchk root left NULL root left val root val lchk lHeight root right NULL root right val root val rchk rHeight res res lchk rchk res lchk rchk return lchk rchk lchk rchk int longestSamevaluePath struct Node root root NULL return solve root return res int main struct Node root NULL root newNode root left newNode root right newNode root left left newNode root left right newNode root right right newNode printf \"%d\\n\" longestSamevaluePath root )); return Get over 200+ course One Subscription Courses like AI/ML, Cloud Computing, Ethical Hacking, C, C++, Java, Python, DSA (All Languages), Competitive Coding (All Languages), TCS, Infosys, Wipro, Amazon, DBMS, SQL and others Get Prime Course List Course List Checkout list of all the video courses in PrepInsta Prime Subscription Checkout list of all the video courses in PrepInsta Prime Subscription Checkout Checkout Login/Signup to comment 30+ Companies are Hiring Get Hiring Updates right in your inbox from PrepInsta"
      }
    ]
  },
  "urls": {
    "GeeksforGeeks": "https://www.geeksforgeeks.org/dsa/amazon-sde-sheet-interview-questions-and-answers/",
    "InterviewBit": "https://www.interviewbit.com/amazon-interview-questions/",
    "PrepInsta": "https://prepinsta.com/amazon/"
  }
}